import matplotlib.pyplot as plt
import numpy as np
import scipy as sp
from pathlib import Path
import itertools

from FisInMa.model import FisherResults, FisherModelParametrized
from FisInMa.solving import calculate_fisher_criterion


def plot_all_odes(fsr: FisherResults, outdir=Path("."), additional_name=""):
    """Plots results of the ODE with time points at which the ODE is evaluated
    for every input combination.

    :param fsr: Results generated by an optimization or solving routine.
    :type fsr: FisherResults
    :param outdir: Output directory to store the images in. Defaults to Path(".").
    :type outdir: Path, optional
    """
    for i, sol in enumerate(fsr.individual_results):
        # Get ODE solutions
        r = sol.ode_solution

        n_x = len(sol.ode_x0)

        # Get time interval over which to plot
        times_low = sol.ode_t0
        times_high = fsr.variable_definitions.times.ub if fsr.variable_definitions.times is not None else np.max(sol.times)
        
        # Solve the ODE on a sufficiently filled interval
        t_values = np.linspace(times_low, times_high)
        res = sp.integrate.solve_ivp(fsr.ode_fun, (times_low, times_high), sol.ode_x0, t_eval=t_values, args=(sol.inputs, sol.parameters, sol.ode_args))
        t = np.array(res.t)
        y = np.array(res.y)

        # Plot the solution and store in individual files
        for j in range(n_x):
            # Create figures and axis
            fig, ax = plt.subplots(figsize=(10, 6))

            # Plot the continuous ODE solution
            ax.plot(t, y[j], color="#21918c", label="Ode Solution")
            
            # Determine where multiple time points overlap by rounding
            ax.scatter(sol.ode_solution.t, sol.ode_solution.y[j], s=160, alpha=0.5, color="#440154", label="Time Points: " + str(sol.inputs))
            ax.legend()
            # TODO - add table with parameters, inputs, ode_t0, ode_y0, etc.
            fig.savefig(outdir / Path("ODE_Result_{}_{}_{}_{:03.0f}_x_{:02.0f}.svg".format(fsr.ode_fun.__name__, fsr.criterion_fun.__name__ , additional_name, i, j)))

            # Remove figure to free space
            plt.close(fig)

def plot_all_observables(fsr: FisherResults, outdir=Path("."), additional_name=""):
    """Plots the observables with time points chosen for Optimal Experimental Design.

    :param fsr: Results generated by an optimization or solving routine.
    :type fsr: FisherResults
    :param outdir: Output directory to store the images in. Defaults to Path(".").
    :type outdir: Path, optional
    """
    for i, sol in enumerate(fsr.individual_results):
        # Get time interval over which to plot
        times_low = sol.ode_t0
        times_high = fsr.variable_definitions.times.ub if fsr.variable_definitions.times is not None else np.max(sol.times)
        
        # Solve the ODE on a sufficiently filled interval
        t_values = np.linspace(times_low, times_high)
        res = sp.integrate.solve_ivp(fsr.ode_fun, (times_low, times_high), sol.ode_x0, t_eval=t_values, args=(sol.inputs, sol.parameters, sol.ode_args))
        t = np.array(res.t)
        y = np.array(res.y)

        # Get ODE solutions
        if callable(fsr.obs_fun) and callable(fsr.obs_dgdp) and callable(fsr.obs_dgdx):
            n_obs = np.array(fsr.obs_fun(sol.ode_t0, sol.ode_x0, sol.inputs, sol.parameters, sol.ode_args)).size
            obs = np.array([fsr.obs_fun(ti, y[:,i_t], sol.inputs, sol.parameters, sol.ode_args) for i_t, ti in enumerate(t)]).reshape((-1, n_obs)).T
        else:
            n_obs = len(sol.ode_x0)
            obs = y

        # Plot the solution and store in individual files
        for j in range(n_obs):
            # Create figures and axis
            fig = plt.figure(figsize=(10, 6))
            ax = plt.axes([0.12, 0.3, 0.8, 0.6])

            # Plot the continuous ODE solution
            ax.plot(t, obs[j], color="#21918c", label="Model Solution", linewidth=2)

            # Plot the solutions
            ax.scatter(sol.times, sol.observables[j], s=160, alpha=0.5, color="#440154", label="Optimal Design")
            ax.set_xlabel("Time", fontsize=15)
            ax.set_ylabel(f"Observable {j}", fontsize=15)
            ax.tick_params(axis="y", labelsize=12)
            ax.tick_params(axis="x", labelsize=12)
            ax.legend(fontsize=16, framealpha=0.5)

            # Add table with resulting values (inputs and times)
            rows = ['Inputs', 'Time points']
            cell_text = [
                [[round(inp,1) for inp in sol.inputs]], 
                [[round(t, 1) for t in sol.times]],
                ]
            table = ax.table(cellText=cell_text,
                      rowLabels=rows,
                      loc='bottom',
                      colLoc='center',
                      bbox = [0.15, -0.4, 0.85, 0.2]
                      )
            table.set_fontsize(11)
            table.scale(0.7, 1.2)
            # TODO - add table with parameters, inputs, ode_t0, ode_y0, etc.
            fig.savefig(outdir / Path("Observables_Result_{}_{}_{}_{:03.0f}_x_{:02.0f}.svg".format(fsr.ode_fun.__name__, fsr.criterion_fun.__name__ , additional_name, i, j)), bbox_inches='tight')
            # Remove figure to free space
            plt.close(fig)


def plot_all_sensitivities(fsr: FisherResults, outdir=Path("."), additional_name=""):
    r"""Plots results of the sensitivities :math:`s_{ij} = \frac{\partial y_i}{\partial p_j}` or , in case of relative sensitivities, :math:`s_{ij} = \frac{\partial y_i}{\partial p_j} \frac{p_j}{y_i}` with time points at which the ODE is evaluated
    for every input combination.
    :param fsr: Results generated by an optimization or solving routine.
    :type fsr: FisherResults
    :param outdir: Output directory to store the images in. Defaults to Path(".")., defaults to Path(".")
    :type outdir: Path, optional
    """
    times_low = fsr.ode_t0
    times_high = fsr.times_def.ub if fsr.times_def is not None else np.max(fsr.times)
    t_values = np.linspace(times_low, times_high, 1000)

    fsmp_args = {key:value for key, value in fsr.__dict__.items() if not key.startswith('_')}

    fsmp = FisherModelParametrized(**fsmp_args)
    fsmp.times = t_values.reshape(fsmp.times.shape[0:-1] + (-1,))

    fsr_new = calculate_fisher_criterion(fsmp, fsr.criterion_fun, relative_sensitivities=fsr.relative_sensitivities, verbose=False)

    for i, (sol, sol_new) in enumerate(zip(fsr.individual_results, fsr_new.individual_results)):
        n_x = len(fsr.ode_x0[0])
        n_obs = len(fsr_new.obs_fun(sol.ode_t0, sol.ode_x0, sol.inputs, sol.parameters, sol.ode_args)) if callable(fsr_new.obs_fun) else n_x
        n_p = len(fsr_new.parameters)
        n_p_full = n_p + (n_x if callable(fsr.ode_dfdx0) else 0)

        for j, k in itertools.product(range(n_obs), range(n_p_full)):
            r = sol.sensitivities[k, j]
            y = sol_new.sensitivities[k, j]

            # Create figure and axis
            fig, ax = plt.subplots(figsize=(10, 6))
            ax.plot(sol_new.times, y, color="#21918c", label="Sensitivities Solution", linewidth=2)

            # Plot sampled time points
            ax.scatter(sol.times, r, s=160, alpha=0.5, color="#440154", label="Optimal Design")
            ax.set_xlabel("Time", fontsize=15)
            ax.set_ylabel("Sensitivity", fontsize=15)
            ax.tick_params(axis="y", labelsize=12)
            ax.tick_params(axis="x", labelsize=12)
            ax.legend(fontsize=15, framealpha=0.5)
            ax.set_title(f"Observable number: {j},  Inputs: {[round(inp, 1) for inp in sol.inputs]}", fontsize=14)
            fig.savefig(outdir / Path("Sensitivities_Results_{}_{}_{}_{:03.0f}_x_{:02.0f}_p_{:02.0f}.svg".format(fsr.ode_fun.__name__, fsr.criterion_fun.__name__ , additional_name, i, j, k)), bbox_inches='tight')

            # Remove figure to free space
            plt.close(fig)


def plot_all_solutions(fsr: FisherResults, outdir=Path("."), additional_name=""):
    r"""Combines functionality of plot_all_odes and plot_all_sensitivities.
    Plots results of the ODE with time points at which the ODE is evaluated
    and results of the sensitivities :math:`s_{ij} = \frac{\partial y_i}{\partial p_j}`
    with time points at which the ODE is evaluated for every input combination.

    :param fsr: Results generated by an optimization or solving routine.
    :type fsr: FisherResults
    :param outdir: Output directory to store the images in. Defaults to Path(".")., defaults to Path(".")
    :type outdir: Path, optional
    """
    plot_all_odes(fsr, outdir)
    plot_all_sensitivities(fsr, outdir)


# TODO - find way to plot json dump from database
